use crate::{
    error::{BoardError, ErrorKind},
    move_gen,
    moves::{Move, MoveState},
    piece::{Color, Piece, PieceKind},
    square::Square,
    squares, Board, Castle,
};

impl Board {
    /// Makes a move, checking to see if it is legal before making it.
    ///
    /// # Errors
    ///
    /// Returns a [BoardError] if the move is not legal
    pub fn make(&mut self, mv: Move) -> Result<(), BoardError> {
        let piece = self[mv.origin];
        if !piece.is_color(self.color_to_move()) {
            // Piece is not empty and matches color
            return Err(BoardError::new(
                ErrorKind::InvalidInput,
                "Attempted to move wrong color",
            ));
        }
        let moves = move_gen::for_square(self, mv.origin);
        if !moves.contains(&mv) {
            return Err(BoardError::new(ErrorKind::InvalidInput, "Invalid move"));
        }
        //Move is valid, and legal
        unsafe {
            self.make_unchecked(mv);
        }

        Ok(())
    }

    /// Unmakes the last move made. If no moves have been made, nothing happens.
    pub fn unmake(&mut self) {
        let ms = match self.move_history.pop() {
            Some(m) => m,
            None => return,
        };
        let piece @ Piece::Filled(kind, color) = (match ms.mv.promotion {
            Piece::Empty => self[ms.mv.dest],
            Piece::Filled(_, color) => Piece::pawn(color),
        }) else {
            panic!("No moving an empty piece")
        };

        let Move {
            origin,
            dest,
            promotion: _,
        } = ms.mv;

        self.modify(|modifier| {
            modifier.put(piece, origin);
            modifier.put(ms.capture, dest);

            let is_ep = matches!(ms.ep_target, Some(e) if e == dest) && kind == PieceKind::Pawn;

            if is_ep {
                let bit_index = (ms.mv.origin.index() & !0b111) | (ms.mv.dest.index() & 0b111);
                let sqr = bit_index.try_into().expect("EP target wrong");
                modifier.put(ms.capture, sqr);
                modifier.clear(dest);
            }

            let is_castle = kind == PieceKind::King && dest.index().abs_diff(origin.index()) == 2;

            let is_ks_castle = is_castle && dest.index() < origin.index();
            if is_castle {
                let (r_origin, r_dest) = match (is_ks_castle, color) {
                    (true, Color::White) => (squares::H1, squares::F1),
                    (true, Color::Black) => (squares::H8, squares::F8),
                    (false, Color::White) => (squares::A1, squares::D1),
                    (false, Color::Black) => (squares::A8, squares::D8),
                };
                modifier.r#move(r_dest, r_origin);
            }
            modifier.toggle_color_to_move();
            // Reset hash-tracked metadata
            modifier.set_castle(Color::White, ms.castle[Color::White]);
            modifier.set_castle(Color::Black, ms.castle[Color::Black]);
            modifier.set_ep_target(ms.ep_target);
        });

        // Resetting other metadata
        if color == Color::Black {
            self.fullmove -= 1;
        }
        self.halfmove = ms.halfmove;
    }

    /// Make a move without checking to see if it is legal. A significant performance improvement
    /// over the regular `make` method.
    ///
    /// # Safety
    ///
    /// Only use in situations where the move being made is known to be legal and valid, typically
    /// when it was generated by the built-in [move_gen].
    ///
    /// # Panics
    ///
    /// Panics if the [Piece] at the moves origin is Empty.
    pub unsafe fn make_unchecked(
        &mut self,
        mv @ Move {
            origin,
            dest,
            promotion,
        }: Move,
    ) {
        let piece @ Piece::Filled(kind, color) = self[origin] else {
            panic!("Moving empty piece")
        };

        let ms = self.modify(|modifier| -> MoveState {
            let is_ep = matches!(modifier.board().ep_target, Some(e) if e == dest)
                && kind == PieceKind::Pawn;

            let mut capture = modifier.r#move(origin, dest);
            if is_ep {
                let index = (origin.index() & !0b111) | (dest.index() & 0b111);
                capture = modifier.clear(index.try_into().expect("EP target wrong"));
            }
            let move_state = MoveState {
                mv,
                capture,
                castle: modifier.board().castle,
                halfmove: modifier.board().halfmove,
                ep_target: modifier.board().ep_target,
            };
            if promotion != Piece::Empty {
                modifier.put(promotion, dest);
            }

            let is_castle = kind == PieceKind::King && dest.index().abs_diff(origin.index()) == 2;
            let is_ks_castle: bool = is_castle && dest.index() < origin.index();
            if is_castle {
                let (r_origin, r_dest) = match (is_ks_castle, color) {
                    (true, Color::White) => (squares::H1, squares::F1),
                    (true, Color::Black) => (squares::H8, squares::F8),
                    (false, Color::White) => (squares::A1, squares::D1),
                    (false, Color::Black) => (squares::A8, squares::D8),
                };
                modifier.r#move(r_origin, r_dest);
            }
            modifier.toggle_color_to_move();

            let is_dp = kind == PieceKind::Pawn && dest.index().abs_diff(origin.index()) == 16;
            if is_dp {
                let index = origin.index().max(dest.index()) - 8;
                modifier.set_ep_target(Some(
                    Square::try_from(index).expect("Bad Ep target calculation"),
                ));
            } else {
                modifier.set_ep_target(None);
            }

            // Update castling
            match kind {
                PieceKind::King => modifier.set_castle(color, Castle::None),
                PieceKind::Rook => match (origin, color) {
                    (squares::A1, Color::White) | (squares::A8, Color::Black) => modifier
                        .set_castle(color, modifier.board().castle[color].with_queen_side(false)),
                    (squares::H1, Color::White) | (squares::H8, Color::Black) => modifier
                        .set_castle(color, modifier.board().castle[color].with_king_side(false)),
                    _ => (),
                },
                _ => (),
            }
            match (dest, capture) {
                (squares::A1, Piece::Filled(PieceKind::Rook, color @ Color::White))
                | (squares::A8, Piece::Filled(PieceKind::Rook, color @ Color::Black)) => {
                    modifier
                        .set_castle(color, modifier.board().castle[color].with_queen_side(false));
                }
                (squares::H1, Piece::Filled(PieceKind::Rook, color @ Color::White))
                | (squares::H8, Piece::Filled(PieceKind::Rook, color @ Color::Black)) => {
                    modifier
                        .set_castle(color, modifier.board().castle[color].with_king_side(false));
                }
                _ => (),
            }

            move_state
        });

        // Updating metadata
        self.move_history.push(ms);
        if piece.is_color(Color::Black) {
            self.fullmove += 1
        }
        if ms.capture == Piece::Empty && piece.is_kind(PieceKind::Pawn) {
            self.halfmove += 1;
        } else {
            self.halfmove = 0;
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use crate::piece::Color;
    use crate::ALL;
    use crate::{moves::Move, piece::Piece, Board};

    impl Board {
        fn is_valid(&self) -> bool {
            let white_pieces = self[Color::White];
            let black_pieces = self[Color::Black];
            let empty = self[Piece::Empty];
            (white_pieces & black_pieces).is_empty()
                && (white_pieces & empty).is_empty()
                && (black_pieces & empty).is_empty()
                && white_pieces | black_pieces | empty == ALL
        }
    }

    #[test]
    fn test_make() {
        let mut board =
            Board::from_fen("rnbqkbnr/ppp2ppp/3p4/3Pp3/8/8/PPP1PPPP/RNBQKBNR w KQkq e6 0 3")
                .unwrap();
        let _mv = board.legal_moves()[0];
        let m = Move::from_str("d5e6").unwrap();
        board.make(m).unwrap();
        assert_eq!(
            board.to_fen(),
            "rnbqkbnr/ppp2ppp/3pP3/8/8/8/PPP1PPPP/RNBQKBNR b KQkq - 0 3"
        );
        assert!(board.is_valid());
    }

    #[test]
    fn test_move_sequence() {
        let fen = "rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8";
        let mut board = Board::from_fen(fen).unwrap();
        let mvs = ["d7c8q", "b8a6", "c4a6"];
        for mv in mvs {
            let m = Move::from_str(mv).unwrap();
            board.make(m).unwrap();
            assert!(board.is_valid());
        }
        for _mv in mvs.iter().rev() {
            board.unmake();
            assert!(board.is_valid());
        }
    }
}
